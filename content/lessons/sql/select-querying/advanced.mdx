# SELECT: Advanced Query Techniques

Master complex SELECT patterns for enterprise-grade SQL development.

## Query Execution Order

Understanding execution order helps write better queries:

```
1. FROM      - Identify source tables
2. WHERE     - Filter rows
3. GROUP BY  - Aggregate rows
4. HAVING    - Filter groups
5. SELECT    - Choose columns (aliases created here)
6. DISTINCT  - Remove duplicates
7. ORDER BY  - Sort results (can use aliases)
8. TOP/LIMIT - Limit rows
```

```sql
-- This works (ORDER BY runs after SELECT)
SELECT price * 1.1 AS adjusted_price FROM products ORDER BY adjusted_price;

-- This fails (WHERE runs before SELECT)
SELECT price * 1.1 AS adjusted_price FROM products WHERE adjusted_price > 100;
-- Error: Invalid column name 'adjusted_price'
```

## Window Functions in SELECT

```sql
SELECT
    employee_id,
    department,
    salary,
    -- Ranking
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS overall_rank,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank,

    -- Running totals
    SUM(salary) OVER (ORDER BY hire_date) AS running_total,

    -- Comparisons
    salary - AVG(salary) OVER (PARTITION BY department) AS diff_from_avg,
    LAG(salary) OVER (ORDER BY hire_date) AS prev_salary,
    LEAD(salary) OVER (ORDER BY hire_date) AS next_salary,

    -- Percentages
    salary * 100.0 / SUM(salary) OVER () AS pct_of_total
FROM employees;
```

## Complex Subquery Patterns

### Correlated Subqueries

```sql
SELECT
    p.product_name,
    p.price,
    (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS category_avg,
    p.price - (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS diff_from_avg
FROM products p;
```

### Lateral Joins (PostgreSQL)

```sql
SELECT c.customer_name, recent.*
FROM customers c
CROSS JOIN LATERAL (
    SELECT order_date, total
    FROM orders
    WHERE customer_id = c.id
    ORDER BY order_date DESC
    LIMIT 3
) recent;
```

### CROSS APPLY (SQL Server)

```sql
SELECT c.customer_name, recent.order_date, recent.total
FROM customers c
CROSS APPLY (
    SELECT TOP 3 order_date, total
    FROM orders
    WHERE customer_id = c.id
    ORDER BY order_date DESC
) recent;
```

## Pivoting Data

```sql
-- SQL Server PIVOT
SELECT * FROM (
    SELECT year, quarter, revenue
    FROM sales_data
) src
PIVOT (
    SUM(revenue) FOR quarter IN ([Q1], [Q2], [Q3], [Q4])
) pvt;

-- Cross-tab via CASE (works everywhere)
SELECT
    product_id,
    SUM(CASE WHEN YEAR(sale_date) = 2022 THEN amount END) AS "2022",
    SUM(CASE WHEN YEAR(sale_date) = 2023 THEN amount END) AS "2023",
    SUM(CASE WHEN YEAR(sale_date) = 2024 THEN amount END) AS "2024"
FROM sales
GROUP BY product_id;
```

## Performance Optimization

### SELECT Only What You Need

```sql
-- Bad: Retrieves all columns
SELECT * FROM large_table;

-- Good: Only requested columns
SELECT id, name FROM large_table;

-- Best: Covered by index
SELECT id, name FROM large_table WHERE status = 'active';
-- If index exists on (status) INCLUDE (id, name)
```

### Avoiding Repeated Calculations

```sql
-- Bad: Calculation repeated
SELECT
    quantity * price AS total,
    quantity * price * 0.1 AS tax,
    quantity * price * 1.1 AS grand_total
FROM orders;

-- Better: Use CTE or derived table
WITH calculated AS (
    SELECT *, quantity * price AS total
    FROM orders
)
SELECT
    total,
    total * 0.1 AS tax,
    total * 1.1 AS grand_total
FROM calculated;
```

<ProgressCheckpoint section="select-querying-complete" xpReward={60} />
