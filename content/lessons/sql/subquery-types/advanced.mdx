# Subquery Types: Advanced Patterns

Expert-level subquery techniques and optimization.

## Recursive CTEs as Subqueries

```sql
-- Hierarchical data
WITH RECURSIVE org_tree AS (
    SELECT id, name, manager_id, 1 AS level
    FROM employees WHERE manager_id IS NULL
    UNION ALL
    SELECT e.id, e.name, e.manager_id, t.level + 1
    FROM employees e
    JOIN org_tree t ON e.manager_id = t.id
)
SELECT * FROM org_tree ORDER BY level, name;

-- Date series generation
WITH RECURSIVE date_series AS (
    SELECT CAST('2024-01-01' AS DATE) AS dt
    UNION ALL
    SELECT DATEADD(DAY, 1, dt) FROM date_series WHERE dt < '2024-12-31'
)
SELECT * FROM date_series;
```

## Subquery Factoring Performance

```sql
-- Multiple uses of same subquery
WITH expensive_calc AS (
    SELECT product_id, SUM(quantity * price) AS revenue
    FROM order_items
    JOIN products ON order_items.product_id = products.id
    GROUP BY product_id
)
SELECT
    p.*,
    e.revenue,
    e.revenue / (SELECT SUM(revenue) FROM expensive_calc) AS revenue_pct
FROM products p
JOIN expensive_calc e ON p.id = e.product_id;
```

## Type Coercion in Subqueries

```sql
-- Scalar must match expected type
SELECT * FROM products
WHERE price > (SELECT CAST(AVG(price) AS DECIMAL(10,2)) FROM products);

-- Column subquery type matching
SELECT * FROM orders
WHERE customer_id IN (
    SELECT CAST(customer_id AS INT) FROM external_customers
);
```

## Subquery in INSERT/UPDATE/DELETE

```sql
-- INSERT with subquery
INSERT INTO product_archive
SELECT * FROM products
WHERE id IN (SELECT product_id FROM discontinued);

-- UPDATE with table subquery
UPDATE p
SET p.category_rank = sub.rank
FROM products p
JOIN (
    SELECT id, RANK() OVER (PARTITION BY category ORDER BY price DESC) AS rank
    FROM products
) sub ON p.id = sub.id;

-- DELETE with subquery
DELETE FROM orders
WHERE customer_id IN (
    SELECT id FROM customers WHERE is_deleted = 1
);
```

## Subquery vs MERGE

```sql
-- Complex upsert with subquery
MERGE INTO target t
USING (
    SELECT id, MAX(value) AS latest_value
    FROM source
    GROUP BY id
) s ON t.id = s.id
WHEN MATCHED THEN UPDATE SET value = s.latest_value
WHEN NOT MATCHED THEN INSERT (id, value) VALUES (s.id, s.latest_value);
```

## Query Optimization Comparison

```sql
-- Same result, different approaches:

-- 1. Correlated scalar subquery
SELECT *,
    (SELECT COUNT(*) FROM orders WHERE customer_id = c.id) AS order_count
FROM customers c;

-- 2. Derived table with JOIN
SELECT c.*, COALESCE(o.order_count, 0) AS order_count
FROM customers c
LEFT JOIN (
    SELECT customer_id, COUNT(*) AS order_count FROM orders GROUP BY customer_id
) o ON c.id = o.customer_id;

-- 3. Window function (if lateral/apply available)
SELECT c.*, COUNT(o.id) OVER (PARTITION BY c.id) AS order_count
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id;

-- #2 typically performs best for this pattern
```

## Subquery Debugging

```sql
-- Test subquery in isolation
SELECT customer_id, COUNT(*) AS cnt FROM orders GROUP BY customer_id;

-- Verify it returns expected type
-- Scalar: Single row, single column
-- Column: Multiple rows, single column
-- Table: Multiple rows, multiple columns

-- Check for NULLs that might affect NOT IN
SELECT * FROM (your_subquery) t WHERE some_column IS NULL;
```

<ProgressCheckpoint section="subquery-types-complete" xpReward={45} />
