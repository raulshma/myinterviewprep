# Optimizing JOIN Operations: Advanced Topics

Expert-level JOIN optimization strategies.

## Join Order Optimization

```sql
-- Optimizer usually chooses best order
-- But can force with OPTION (FORCE ORDER)
SELECT * FROM A
JOIN B ON A.id = B.a_id
JOIN C ON B.id = C.b_id
OPTION (FORCE ORDER);  -- Uses written order

-- Best practice: Write FROM in logical order
-- Start with smallest filtered table
```

## Adaptive Joins (SQL Server 2017+)

```sql
-- Optimizer can switch between Nested Loop and Hash at runtime
-- Based on actual row counts

-- Enable with compatibility level 140+
ALTER DATABASE mydb SET COMPATIBILITY_LEVEL = 140;

-- Optimizer automatically adapts based on cardinality
```

## Star Schema Optimization

```sql
-- Data warehouse optimization
-- Fact table with dimension tables

-- Bitmap filtering for dimension conditions
SELECT SUM(f.sales)
FROM fact_sales f
JOIN dim_product p ON f.product_key = p.key
JOIN dim_time t ON f.time_key = t.key
WHERE p.category = 'Electronics'
AND t.year = 2024;

-- SQL Server: Enable star join hints
SELECT * FROM fact_sales f
JOIN dim_product p ON f.product_key = p.key
OPTION (USE HINT ('ENABLE_QUERY_OPTIMIZER_HOTFIXES'));
```

## Partitioned Table Joins

```sql
-- Partition elimination in JOINs
CREATE TABLE orders_partitioned (
    id INT,
    order_date DATE,
    customer_id INT
) PARTITION BY RANGE (order_date);

-- Query on partition key enables pruning
SELECT * FROM orders_partitioned o
JOIN customers c ON o.customer_id = c.id
WHERE o.order_date BETWEEN '2024-01-01' AND '2024-01-31';
-- Only scans relevant partition
```

## Parallel Hash Joins

```sql
-- SQL Server: Control parallelism
SELECT * FROM large_table1 l1
JOIN large_table2 l2 ON l1.id = l2.foreign_id
OPTION (MAXDOP 4);  -- Use 4 cores

-- Monitor for spills
-- Hash spill to tempdb = need more memory
```

## Join Hints

```sql
-- SQL Server: Force join type
SELECT * FROM orders o
INNER LOOP JOIN customers c ON o.customer_id = c.id;  -- Force nested loop

SELECT * FROM orders o
INNER HASH JOIN customers c ON o.customer_id = c.id;  -- Force hash

SELECT * FROM orders o
INNER MERGE JOIN customers c ON o.customer_id = c.id; -- Force merge

-- PostgreSQL
SET enable_hashjoin = OFF;
SET enable_mergejoin = OFF;
```

## Anti-Join Optimization

```sql
-- Find rows not in other table
-- Best methods:

-- LEFT JOIN + NULL check
SELECT c.* FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE o.id IS NULL;

-- NOT EXISTS (often fastest)
SELECT c.* FROM customers c
WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.id);

-- NOT IN (be careful with NULLs)
SELECT * FROM customers
WHERE id NOT IN (SELECT customer_id FROM orders WHERE customer_id IS NOT NULL);
```

<QueryOptimizer mode="advanced" />

<ProgressCheckpoint section="optimizing-joins-complete" xpReward={50} />
