# Nested Subqueries: Advanced Patterns

Enterprise-grade subquery techniques and optimization.

## Subquery Optimization

### Avoid N+1 Queries

```sql
-- SLOW: Scalar subquery executed per row
SELECT
    p.*,
    (SELECT COUNT(*) FROM order_items WHERE product_id = p.id) AS times_ordered
FROM products p;

-- FAST: Join once
SELECT p.*, COALESCE(oi.times_ordered, 0) AS times_ordered
FROM products p
LEFT JOIN (
    SELECT product_id, COUNT(*) AS times_ordered
    FROM order_items GROUP BY product_id
) oi ON p.id = oi.product_id;
```

### IN vs EXISTS

```sql
-- IN: Good for small subquery results
SELECT * FROM customers
WHERE id IN (SELECT customer_id FROM orders);

-- EXISTS: Better for large tables with index
SELECT * FROM customers c
WHERE EXISTS (SELECT 1 FROM orders WHERE customer_id = c.id);

-- EXISTS short-circuits: stops at first match
```

## Complex Derived Tables

```sql
-- Multiple levels of aggregation
SELECT
    region,
    AVG(customer_revenue) AS avg_customer_revenue
FROM (
    SELECT
        c.region,
        c.id AS customer_id,
        SUM(o.total) AS customer_revenue
    FROM customers c
    JOIN orders o ON c.id = o.customer_id
    GROUP BY c.region, c.id
) customer_totals
GROUP BY region;
```

## Lateral Subqueries

```sql
-- PostgreSQL: LATERAL allows correlation
SELECT c.*, recent_orders.*
FROM customers c
CROSS JOIN LATERAL (
    SELECT * FROM orders
    WHERE customer_id = c.id
    ORDER BY order_date DESC
    LIMIT 3
) recent_orders;

-- SQL Server: CROSS APPLY (equivalent)
SELECT c.*, recent_orders.*
FROM customers c
CROSS APPLY (
    SELECT TOP 3 * FROM orders
    WHERE customer_id = c.id
    ORDER BY order_date DESC
) recent_orders;
```

## Subquery Factoring with CTEs

```sql
WITH RECURSIVE category_tree AS (
    -- Anchor
    SELECT id, name, parent_id, 1 AS level
    FROM categories WHERE parent_id IS NULL
    UNION ALL
    -- Recursive
    SELECT c.id, c.name, c.parent_id, ct.level + 1
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree;
```

## Subquery in UPDATE/DELETE

```sql
-- Update based on subquery
UPDATE products
SET featured = 1
WHERE id IN (
    SELECT product_id FROM order_items
    GROUP BY product_id
    ORDER BY SUM(quantity) DESC
    LIMIT 10
);

-- Delete orphans
DELETE FROM orders
WHERE customer_id NOT IN (SELECT id FROM customers);
```

## Query Plan Analysis

```sql
-- Check if subquery is materialized or inlined
-- SQL Server
SET STATISTICS PROFILE ON;
SELECT * FROM products WHERE price > (SELECT AVG(price) FROM products);
SET STATISTICS PROFILE OFF;

-- Look for:
-- • Scalar subquery: Good
-- • Table Spool: Subquery materialized
-- • Nested Loops: Correlated, might be slow
```

## Subquery Best Practices

| Pattern          | Use Case         | Alternative     |
| ---------------- | ---------------- | --------------- |
| Scalar in SELECT | Add single value | Window function |
| IN/NOT IN        | Filter on list   | JOIN/EXISTS     |
| Derived table    | Pre-aggregate    | CTE for clarity |
| Correlated       | Row-by-row logic | LATERAL/APPLY   |

<ProgressCheckpoint section="nested-advanced" xpReward={55} />
