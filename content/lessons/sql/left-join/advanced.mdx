# LEFT JOIN: Advanced Techniques

Enterprise patterns and optimization for LEFT JOIN.

## Performance Optimization

```sql
-- Index on join column is critical
CREATE INDEX IX_orders_customer ON orders(customer_id);

-- LEFT JOIN can be slower than INNER JOIN
-- Optimizer has fewer options for row elimination
```

## Exclusive LEFT JOIN (Anti-Join)

```sql
-- Most efficient anti-join
-- Option 1: LEFT JOIN + IS NULL
SELECT a.* FROM table_a a
LEFT JOIN table_b b ON a.id = b.a_id
WHERE b.a_id IS NULL;

-- Option 2: NOT EXISTS (often same performance)
SELECT a.* FROM table_a a
WHERE NOT EXISTS (SELECT 1 FROM table_b WHERE a_id = a.id);

-- Option 3: NOT IN (can be slower, NULL issues)
SELECT * FROM table_a WHERE id NOT IN (SELECT a_id FROM table_b WHERE a_id IS NOT NULL);
```

## Multiple Outer Joins

```sql
-- Chain of LEFT JOINs
SELECT *
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
LEFT JOIN payments p ON o.id = p.order_id
LEFT JOIN refunds r ON p.id = r.payment_id;

-- Each subsequent table may have NULLs cascading
```

## Conditional Aggregates with LEFT JOIN

```sql
SELECT
    c.name,
    COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders,
    COUNT(CASE WHEN o.status = 'pending' THEN 1 END) AS pending_orders,
    COALESCE(SUM(CASE WHEN o.status = 'completed' THEN o.total END), 0) AS revenue
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.id, c.name;
```

## Query Plan Analysis

```sql
-- SQL Server: Check for "Nested Loops (Left Outer Join)"
SET STATISTICS PROFILE ON;
SELECT * FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id;

-- Hash Match (Left Outer) for larger tables
-- Merge Join (Left Outer) if both sorted
```

## LEFT JOIN in Updates

```sql
-- Update based on LEFT JOIN (SQL Server)
UPDATE c
SET c.last_order_date = o.max_date
FROM customers c
LEFT JOIN (
    SELECT customer_id, MAX(order_date) AS max_date
    FROM orders GROUP BY customer_id
) o ON c.id = o.customer_id;

-- PostgreSQL
UPDATE customers c
SET last_order_date = o.max_date
FROM (
    SELECT customer_id, MAX(order_date) AS max_date
    FROM orders GROUP BY customer_id
) o
WHERE c.id = o.customer_id;
```

## Avoiding Common Mistakes

```sql
-- Wrong: Aggregate in WHERE with LEFT JOIN
SELECT c.*, COUNT(o.id)
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE COUNT(o.id) > 0;  -- ERROR! Use HAVING

-- Wrong: Filtering right table in WHERE (converts to INNER)
SELECT c.*, o.*
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE o.status = 'active';  -- Excludes customers with no orders!

-- Right: Filter in ON clause
LEFT JOIN orders o ON c.id = o.customer_id AND o.status = 'active'
```

<ProgressCheckpoint section="left-join-advanced" xpReward={50} />
