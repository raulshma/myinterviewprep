# Database Design - Advanced

Master advanced database design patterns, denormalization strategies, and enterprise-scale considerations.

## üìê Beyond 3NF

### Boyce-Codd Normal Form (BCNF)

BCNF is stricter than 3NF - every determinant must be a candidate key.

<DotnetCodePreview
  title="BCNF Violation Example"
  code={`-- 3NF but not BCNF
-- Scenario: Teachers teach subjects, each subject taught by one teacher
| StudentId | Subject | Teacher    |
| 1         | Math    | Dr. Smith  |
| 1         | Science | Dr. Jones  |
| 2         | Math    | Dr. Smith  |  -- Same teacher for Math

-- Problem: Subject ‚Üí Teacher, but Subject is not a key!
-- StudentId + Subject is the key

-- BCNF Solution: Split the table
CREATE TABLE TeacherSubjects (
    Subject VARCHAR(100) PRIMARY KEY,
    Teacher VARCHAR(100) NOT NULL
);

CREATE TABLE StudentSubjects (
    StudentId INT,
    Subject VARCHAR(100) REFERENCES TeacherSubjects(Subject),
    PRIMARY KEY (StudentId, Subject)
);`}
  steps={[
    {
      lineNumbers: [7],
      highlight: "Functional dependency",
      explanation: "Subject determines Teacher, but Subject alone isn't a key"
    },
    {
      lineNumbers: [12, 13, 14],
      highlight: "BCNF compliant",
      explanation: "Now Subject is the primary key in its own table"
    }
  ]}
/>

## üîÑ When to Denormalize

Sometimes breaking normalization rules improves performance:

### Reasons to Denormalize

| Scenario | Strategy |
|:---------|:---------|
| Frequent JOINs | Store calculated/aggregated values |
| Read-heavy systems | Duplicate data to avoid joins |
| Reporting tables | Pre-calculate summaries |
| Caching | Store derived data |

<DotnetCodePreview
  title="Denormalization Example"
  code={`-- Normalized: Requires JOIN for every read
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    CustomerId INT REFERENCES Customers(Id),
    Total DECIMAL(10,2)
);

-- Queries always need customer name
SELECT o.*, c.Name 
FROM Orders o 
JOIN Customers c ON o.CustomerId = c.Id;

-- Denormalized: Embed customer name (careful!)
CREATE TABLE Orders (
    Id INT PRIMARY KEY,
    CustomerId INT REFERENCES Customers(Id),
    CustomerName VARCHAR(100),  -- Duplicated!
    Total DECIMAL(10,2)
);

-- Now reads are faster but:
-- - Takes more storage
-- - Need to update both places if name changes
-- - Use triggers or app logic to sync`}
  steps={[
    {
      lineNumbers: [9, 10, 11],
      highlight: "Normalized query",
      explanation: "Always needs JOIN - can be slow at scale"
    },
    {
      lineNumbers: [15],
      highlight: "Denormalized field",
      explanation: "Trades storage for read performance"
    },
    {
      lineNumbers: [20, 21, 22],
      highlight: "Trade-offs",
      explanation: "Must handle data sync carefully"
    }
  ]}
/>

## üìä Index Design Strategy

Design indexes based on query patterns:

<DotnetCodePreview
  title="Strategic Index Design"
  code={`-- Analyze your common queries:

-- Query 1: Find orders by customer in date range
SELECT * FROM Orders 
WHERE CustomerId = ? AND OrderDate BETWEEN ? AND ?;
-- INDEX: (CustomerId, OrderDate)

-- Query 2: Search products by category and price
SELECT * FROM Products 
WHERE CategoryId = ? AND Price < ? 
ORDER BY Price;
-- INDEX: (CategoryId, Price)

-- Query 3: Full-text product search
SELECT * FROM Products 
WHERE Name LIKE '%keyboard%';
-- DON'T use B-tree! Use Full-Text Index

-- Composite Index Order Matters!
CREATE INDEX IX_Orders_Customer_Date 
ON Orders(CustomerId, OrderDate);

-- This index helps:
-- WHERE CustomerId = 5                    ‚úì
-- WHERE CustomerId = 5 AND OrderDate > X  ‚úì

-- But NOT:
-- WHERE OrderDate > X                     ‚úó (can't use leading column)`}
  steps={[
    {
      lineNumbers: [5, 6],
      highlight: "Composite index",
      explanation: "Column order should match WHERE clause order"
    },
    {
      lineNumbers: [10, 11, 12],
      highlight: "Include ORDER BY",
      explanation: "If sorting by Price, include it in index"
    },
    {
      lineNumbers: [23, 24, 27],
      highlight: "Leftmost prefix rule",
      explanation: "Composite indexes work left-to-right"
    }
  ]}
/>

## üèóÔ∏è Design Patterns

### Soft Delete Pattern

<DotnetCodePreview
  title="Soft Delete"
  code={`CREATE TABLE Users (
    Id INT PRIMARY KEY,
    Email VARCHAR(255) NOT NULL,
    IsDeleted BIT DEFAULT 0,
    DeletedAt DATETIME2 NULL
);

-- "Delete" by updating flag
UPDATE Users SET IsDeleted = 1, DeletedAt = GETDATE()
WHERE Id = 42;

-- All queries filter out deleted
CREATE VIEW ActiveUsers AS
SELECT * FROM Users WHERE IsDeleted = 0;

-- Optional: Unique only for active rows
CREATE UNIQUE INDEX IX_Users_Email_Active
ON Users(Email)
WHERE IsDeleted = 0;`}
  steps={[
    {
      lineNumbers: [4, 5],
      highlight: "Soft delete columns",
      explanation: "Track deletion without removing data"
    },
    {
      lineNumbers: [13, 14],
      highlight: "Filtered view",
      explanation: "App uses this view - never sees deleted users"
    },
    {
      lineNumbers: [17, 18, 19],
      highlight: "Filtered unique index",
      explanation: "Allows same email to be 'deleted' then reused"
    }
  ]}
/>

### Audit Trail Pattern

```sql
CREATE TABLE Orders (
    Id INT IDENTITY PRIMARY KEY,
    CustomerId INT NOT NULL,
    Total DECIMAL(18,2) NOT NULL,
    Status VARCHAR(50) NOT NULL,
    
    -- Audit columns
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy VARCHAR(100),
    UpdatedAt DATETIME2,
    UpdatedBy VARCHAR(100),
    Version INT DEFAULT 1
);

-- Audit log table
CREATE TABLE OrderAuditLog (
    Id INT IDENTITY PRIMARY KEY,
    OrderId INT NOT NULL,
    Action VARCHAR(10),  -- INSERT, UPDATE, DELETE
    ChangedAt DATETIME2 DEFAULT GETDATE(),
    ChangedBy VARCHAR(100),
    OldValues NVARCHAR(MAX),  -- JSON of old values
    NewValues NVARCHAR(MAX)   -- JSON of new values
);
```

### Temporal Tables (SQL Server 2016+)

<DotnetCodePreview
  title="System-Versioned Temporal Tables"
  code={`-- Create temporal table (system tracks history automatically!)
CREATE TABLE Products (
    Id INT PRIMARY KEY,
    Name NVARCHAR(100) NOT NULL,
    Price DECIMAL(18,2) NOT NULL,
    
    -- System versioning columns
    SysStartTime DATETIME2 GENERATED ALWAYS AS ROW START,
    SysEndTime DATETIME2 GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime)
)
WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.ProductsHistory));

-- Query current data
SELECT * FROM Products WHERE Id = 1;

-- Query historical data (time travel!)
SELECT * FROM Products FOR SYSTEM_TIME AS OF '2024-01-15'
WHERE Id = 1;

-- See all versions
SELECT * FROM Products FOR SYSTEM_TIME ALL
WHERE Id = 1;`}
  steps={[
    {
      lineNumbers: [8, 9, 10],
      highlight: "System time period",
      explanation: "Database tracks when each version was valid"
    },
    {
      lineNumbers: [12],
      highlight: "History table",
      explanation: "Old versions automatically stored"
    },
    {
      lineNumbers: [18, 19],
      highlight: "Time travel",
      explanation: "Query data as it was at any point in time"
    }
  ]}
/>

## üéØ Schema Versioning

Track database changes with migration scripts:

```sql
-- Create version tracking table
CREATE TABLE SchemaVersions (
    Version INT PRIMARY KEY,
    Description VARCHAR(500),
    AppliedAt DATETIME2 DEFAULT GETDATE(),
    Checksum VARCHAR(100)
);

-- Example migration (001_CreateUsers.sql)
IF NOT EXISTS (SELECT 1 FROM SchemaVersions WHERE Version = 1)
BEGIN
    CREATE TABLE Users (
        Id INT IDENTITY PRIMARY KEY,
        Email VARCHAR(255) NOT NULL
    );
    
    INSERT INTO SchemaVersions (Version, Description)
    VALUES (1, 'Create Users table');
END;
```

<DatabaseDesignVisualizer mode="advanced" />

## Design Checklist

| Category | Best Practice |
|:---------|:--------------|
| **Keys** | Use surrogate keys (INT/UUID) for flexibility |
| **Normalization** | Start at 3NF, denormalize with metrics |
| **Indexes** | Design for query patterns, not just columns |
| **Constraints** | Enforce at database level, not just app |
| **Naming** | Consistent conventions (snake_case or PascalCase) |
| **Audit** | Track CreatedAt, UpdatedAt for all entities |
| **Soft Delete** | Consider for user-facing data |
| **Versioning** | Use temporal tables or audit logs |

<ProgressCheckpoint section="normalization" xpReward={75} />
