# Service Communication

Microservices communicate over the network using various protocols and patterns. Choosing the right communication style impacts your system's reliability, performance, and complexity.

## Communication Patterns

<ServiceCommunicationDemo mode="intermediate" />

## Synchronous Communication

### HTTP REST

The most common approach for service-to-service communication:

```csharp
// OrderService calling PaymentService
public class PaymentClient
{
    private readonly HttpClient _httpClient;

    public async Task<PaymentResult> ProcessPaymentAsync(PaymentRequest request)
    {
        var response = await _httpClient.PostAsJsonAsync(
            "api/payments",
            request
        );
        
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<PaymentResult>();
    }
}
```

**Pros:**
- Simple, well-understood
- Wide tooling support
- Human-readable (JSON)

**Cons:**
- Temporal coupling (both services must be up)
- Higher latency for large payloads
- Text-based serialization overhead

### gRPC

High-performance RPC framework using Protocol Buffers:

```protobuf
// payment.proto
syntax = "proto3";

service PaymentService {
  rpc ProcessPayment (PaymentRequest) returns (PaymentResponse);
}

message PaymentRequest {
  string order_id = 1;
  double amount = 2;
  string currency = 3;
}

message PaymentResponse {
  bool success = 1;
  string transaction_id = 2;
}
```

```csharp
// gRPC client call
var response = await _paymentClient.ProcessPaymentAsync(new PaymentRequest
{
    OrderId = orderId,
    Amount = 99.99,
    Currency = "USD"
});
```

**Pros:**
- Much faster than REST (binary protocol)
- Strongly typed contracts
- Bi-directional streaming

**Cons:**
- Not human-readable
- Browser support requires gRPC-Web
- More complex than REST

## Asynchronous Communication

### Message Queues (RabbitMQ)

Services communicate through a message broker:

```csharp
// Publisher (OrderService)
public class OrderCreatedPublisher
{
    private readonly IModel _channel;

    public void PublishOrderCreated(Order order)
    {
        var message = JsonSerializer.Serialize(new OrderCreatedEvent
        {
            OrderId = order.Id,
            CustomerId = order.CustomerId,
            TotalAmount = order.Total
        });

        var body = Encoding.UTF8.GetBytes(message);
        
        _channel.BasicPublish(
            exchange: "orders",
            routingKey: "order.created",
            body: body
        );
    }
}
```

```csharp
// Consumer (PaymentService)
public class OrderCreatedConsumer : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var consumer = new EventingBasicConsumer(_channel);
        
        consumer.Received += async (model, ea) =>
        {
            var message = Encoding.UTF8.GetString(ea.Body.ToArray());
            var @event = JsonSerializer.Deserialize<OrderCreatedEvent>(message);
            
            await ProcessPaymentAsync(@event);
            
            _channel.BasicAck(ea.DeliveryTag, false);
        };

        _channel.BasicConsume(queue: "payment-orders", consumer: consumer);
    }
}
```

### Event-Driven Architecture

Services publish events when something happens; interested services subscribe:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Order     â”‚       â”‚   Event     â”‚       â”‚  Payment    â”‚
â”‚   Service   â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚    Bus      â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚   Service   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚             â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚             â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚             â”‚â”€â”€â”€â”€â”€â”€â–ºâ”‚   Email     â”‚
                      â”‚             â”‚       â”‚   Service   â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Comparison Table

| Aspect | HTTP REST | gRPC | Message Queue |
| :--- | :--- | :--- | :--- |
| **Type** | Synchronous | Synchronous | Asynchronous |
| **Format** | JSON/XML | Protocol Buffers | Any |
| **Speed** | Moderate | Fast | Depends |
| **Coupling** | Temporal | Temporal | Loose |
| **Complexity** | Low | Medium | High |
| **Use Case** | CRUD APIs | Service-to-Service | Background Jobs |

## Handling Failures

### Retry with Exponential Backoff

```csharp
services.AddHttpClient<IPaymentClient, PaymentClient>()
    .AddTransientHttpErrorPolicy(policy => 
        policy.WaitAndRetryAsync(3, attempt => 
            TimeSpan.FromSeconds(Math.Pow(2, attempt))
        )
    );
```

### Circuit Breaker Pattern

Prevent cascading failures:

```csharp
services.AddHttpClient<IPaymentClient, PaymentClient>()
    .AddTransientHttpErrorPolicy(policy =>
        policy.CircuitBreakerAsync(
            handledEventsAllowedBeforeBreaking: 5,
            durationOfBreak: TimeSpan.FromSeconds(30)
        )
    );
```

## Key Takeaways

- ğŸ”„ **HTTP REST** - Simple, universal, good for most cases
- âš¡ **gRPC** - High performance, strongly typed, for internal services
- ğŸ“¨ **Message Queues** - Loose coupling, reliability, background processing
- ğŸ” Always implement **retries** and **circuit breakers**
- ğŸ¯ Choose based on latency requirements and coupling tolerance

<ProgressCheckpoint section="sc-communication-patterns" xpReward={50} />
