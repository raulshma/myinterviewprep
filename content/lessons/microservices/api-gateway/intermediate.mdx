# API Gateway Pattern

An API Gateway acts as a reverse proxy that routes requests from clients to services, handling cross-cutting concerns like authentication, rate limiting, and request aggregation.

---

## Section 1: What is an API Gateway?

<ApiGatewaySimulator mode="intermediate" />

### Request Routing

The gateway routes incoming requests to appropriate backend services:

```mermaid
flowchart LR
    subgraph Clients
        R1["GET /api/products/123"]
        R2["POST /api/orders"]
        R3["GET /api/users/me"]
    end
    subgraph Gateway
        RM[Route Matching]
    end
    subgraph Services
        CS[Catalog Service]
        OS[Order Service]
        US[User Service]
    end
    R1 --> RM --> CS
    R2 --> RM --> OS
    R3 --> RM --> US
```

### Authentication & Authorization

Centralized security handling:

```mermaid
flowchart TB
    C["Client<br/>(with JWT)"] --> G
    subgraph G[API Gateway]
        direction TB
        E[1. Extract JWT token]
        V[2. Validate signature]
        X[3. Check expiration]
        P[4. Verify permissions]
        E --> V --> X --> P
    end
    G -->|if valid| M[Microservice]
```

<ProgressCheckpoint section="ag-what-is-gateway" xpReward={15} />

---

## Section 2: Gateway Features

### Rate Limiting

Protect services from being overwhelmed:

| Strategy | Description | Use Case |
| :--- | :--- | :--- |
| Fixed Window | X requests per time window | Simple rate limiting |
| Sliding Window | Smooth rate limiting | Avoid burst at window edges |
| Token Bucket | Allows bursts up to limit | Handling traffic spikes |
| Leaky Bucket | Processes at fixed rate | Consistent throughput |

### Request Aggregation

Combine multiple service calls into one:

```mermaid
sequenceDiagram
    participant C as Client
    participant G as API Gateway
    participant U as User Service
    participant O as Order Service
    participant Cat as Catalog Service
    
    C->>G: GET /api/dashboard
    par Parallel Calls
        G->>U: GET /api/users/123
        G->>O: GET /api/orders?userId=123
        G->>Cat: GET /api/recommendations/123
    end
    U-->>G: user data
    O-->>G: orders data
    Cat-->>G: recommendations
    G-->>C: Combined JSON response
```

### BFF Pattern (Backend for Frontend)

Different clients have different needs:

```mermaid
flowchart TB
    subgraph Clients
        MA[Mobile App]
        WA[Web App]
        AA[Admin App]
    end
    subgraph BFFs["Backend for Frontend Layer"]
        MB["Mobile BFF<br/>(compact)"]
        WB["Web BFF<br/>(rich)"]
        AB["Admin BFF<br/>(full)"]
    end
    subgraph Services[Microservices]
        S1[Service 1]
        S2[Service 2]
        S3[Service 3]
    end
    MA --> MB
    WA --> WB
    AA --> AB
    MB --> Services
    WB --> Services
    AB --> Services
```

<ProgressCheckpoint section="ag-gateway-features" xpReward={15} />

---

## Section 3: Implementation Considerations

### Gateway Technologies Comparison

| Gateway | Type | Best For |
| :--- | :--- | :--- |
| **Ocelot** | .NET Library | .NET microservices |
| **YARP** | .NET Library | Modern .NET reverse proxy |
| **Kong** | Standalone | Platform-agnostic |
| **AWS API Gateway** | Cloud Service | Serverless/AWS |
| **Azure API Management** | Cloud Service | Enterprise/Azure |
| **NGINX** | Reverse Proxy | High performance |

### Gateway Anti-Patterns

**Overloaded Gateway** - Don't put business logic in the gateway!

**Single Point of Failure** - Run multiple gateway instances:

```mermaid
flowchart TB
    LB[Load Balancer]
    LB --> G1[Gateway Instance 1]
    LB --> G2[Gateway Instance 2]
    LB --> G3[Gateway Instance 3]
```

### Key Takeaways

- Gateway is the **single entry point** for external clients
- Centralizes **authentication and authorization**
- Handles **rate limiting** to protect services
- **BFF Pattern** provides client-specific gateways
- Don't put **business logic** in the gateway
- Run **multiple instances** for high availability

<ProgressCheckpoint section="ag-implementation" xpReward={15} />
