# Service Lifetimes: Singleton, Scoped, Transient

Understanding service lifetimes is crucial for building reliable ASP.NET Core applications. Each lifetime determines **when instances are created** and **how long they live**.

## The Three Lifetimes Compared

<ServiceLifetimeDemo mode="intermediate" showComparison />

### Singleton Lifetime

A single instance is created on **first request** and reused for the **entire application lifetime**.

```csharp
builder.Services.AddSingleton<IConfigurationService, ConfigurationService>();
```

**Characteristics:**

- Created once, lives until app shuts down
- Shared across all requests and all threads
- Must be **thread-safe** (multiple threads access it simultaneously)
- Best for stateless or thread-safe stateful services

**Ideal Use Cases:**
| Service | Why Singleton? |
|:--------|:---------------|
| `ILogger<T>` | Thread-safe, write to shared output |
| `IConfiguration` | Read-only, doesn't change at runtime |
| `HttpClientFactory` | Manages connection pooling |
| `IMemoryCache` | Application-wide caching |

### Scoped Lifetime

A new instance is created **once per scope** (typically once per HTTP request).

```csharp
builder.Services.AddScoped<IUserContext, UserContext>();
builder.Services.AddScoped<AppDbContext>();
```

**Characteristics:**

- Created at the start of a scope (request)
- Shared within that scope
- Disposed at the end of the scope
- Safe to hold request-specific state

**Ideal Use Cases:**
| Service | Why Scoped? |
|:--------|:------------|
| `DbContext` | One database connection per request |
| `IUserContext` | Current user for the request |
| `IUnitOfWork` | One transaction per request |
| Shopping Cart | One cart per request |

### Transient Lifetime

A **new instance** is created every time the service is requested.

```csharp
builder.Services.AddTransient<IEmailService, SmtpEmailService>();
```

**Characteristics:**

- Brand new instance per injection
- Short-lived, lightweight
- No shared state between instances
- Disposed by the container (if `IDisposable`)

**Ideal Use Cases:**
| Service | Why Transient? |
|:--------|:---------------|
| Validators | Stateless, quick operations |
| Mappers | No state between mappings |
| Formatters | Simple text/data transformations |
| Command handlers | Process single command |

## Instance Creation Behavior

Let's trace what happens across multiple HTTP requests:

```csharp
// Given this setup:
builder.Services.AddSingleton<SingletonService>();
builder.Services.AddScoped<ScopedService>();
builder.Services.AddTransient<TransientService>();
```

### Request 1:

| Service          | Instance Created?       | Which Instance?      |
| :--------------- | :---------------------- | :------------------- |
| SingletonService | ‚úÖ Yes (first time)     | `#1`                 |
| ScopedService    | ‚úÖ Yes                  | `#1` (for Request 1) |
| TransientService | ‚úÖ Yes (each injection) | `#1, #2, #3...`      |

### Request 2:

| Service          | Instance Created? | Which Instance?          |
| :--------------- | :---------------- | :----------------------- |
| SingletonService | ‚ùå No (reuses)    | `#1` (same as before)    |
| ScopedService    | ‚úÖ Yes            | `#2` (new for Request 2) |
| TransientService | ‚úÖ Yes            | `#4, #5, #6...` (new)    |

<InfoBox type="important">
  **Key Insight:** Singleton instances are **reused**, Scoped instances are
  **shared within a request**, Transient instances are **always new**.
</InfoBox>

## Choosing the Right Lifetime

Use this decision tree:

```
Is the service thread-safe AND stateless or immutable?
‚îú‚îÄ‚îÄ YES ‚Üí Consider SINGLETON
‚îÇ   ‚îî‚îÄ‚îÄ Does it hold expensive resources (connections, caches)?
‚îÇ       ‚îî‚îÄ‚îÄ YES ‚Üí Definitely SINGLETON
‚îî‚îÄ‚îÄ NO
    ‚îú‚îÄ‚îÄ Does it need per-request state (user, transaction)?
    ‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Use SCOPED
    ‚îî‚îÄ‚îÄ NO
        ‚îú‚îÄ‚îÄ Is it lightweight and stateless?
        ‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Use TRANSIENT
        ‚îî‚îÄ‚îÄ NO ‚Üí Reconsider your design
```

## Common Mistakes

### ‚ùå Injecting Scoped into Singleton

```csharp
// BAD: Scoped service captured in singleton!
public class MySingleton
{
    private readonly ScopedService _scoped;  // Lives forever now!

    public MySingleton(ScopedService scoped)
    {
        _scoped = scoped;  // WRONG!
    }
}
```

This creates a **captive dependency** - the scoped service is trapped and never refreshed.

### ‚ùå Stateful Singleton Without Thread Safety

```csharp
// BAD: Not thread-safe!
public class CounterService
{
    private int _count = 0;

    public void Increment() => _count++;  // Race condition!
    public int GetCount() => _count;
}
```

Multiple threads can corrupt the count simultaneously.

### ‚ùå DbContext as Singleton

```csharp
// NEVER do this!
builder.Services.AddSingleton<AppDbContext>();  // üíÄ
```

DbContext is not thread-safe and tracks entities - it MUST be Scoped.

## Best Practices

1. **Default to Scoped** - Most services should be scoped
2. **Singleton for configuration/logging** - Stateless, shared services
3. **Transient for stateless utilities** - Quick operations
4. **Never inject shorter lifetime into longer** - Scoped ‚Üí Singleton = BAD

## Key Takeaways

- üíú **Singleton** - One instance forever, must be thread-safe
- üíô **Scoped** - One instance per request, the most common choice
- üíö **Transient** - New instance every injection, for lightweight services
- ‚ö†Ô∏è **Never** inject Scoped into Singleton

<ProgressCheckpoint section="lifetime-comparison" xpReward={40} />
