# The Built-in DI Container

The ASP.NET Core DI container (`Microsoft.Extensions.DependencyInjection`) provides multiple ways to register services, from simple interface-to-implementation mappings to factory-based registrations.

## IServiceCollection Methods

The `IServiceCollection` interface provides methods for all three lifetimes:

<DIContainerExplorer mode="intermediate" />

### Basic Registration Forms

```csharp
// Form 1: Interface ‚Üí Implementation
builder.Services.AddScoped<IUserRepository, UserRepository>();

// Form 2: Self-registration (implementation only)
builder.Services.AddScoped<UserRepository>();

// Form 3: Instance registration (singletons only)
var logger = new ConsoleLogger();
builder.Services.AddSingleton<ILogger>(logger);

// Form 4: Type objects
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
```

### Factory-Based Registration

Use a factory when you need runtime logic or access to other services:

```csharp
// Simple factory
builder.Services.AddScoped<IEmailService>(provider =>
{
    return new SmtpEmailService("smtp.example.com", 587);
});

// Factory with dependencies
builder.Services.AddScoped<IUserService>(provider =>
{
    var repository = provider.GetRequiredService<IUserRepository>();
    var logger = provider.GetRequiredService<ILogger<UserService>>();
    return new UserService(repository, logger);
});
```

<InfoBox type="tip">
  Factory-based registration is useful when: - Constructor requires runtime
  values (connection strings) - You need conditional creation logic - You want
  to wrap with decorators
</InfoBox>

## TryAdd Methods: Safe Registration

`TryAdd*` methods only register if the service **isn't already registered**:

```csharp
// Always adds (may duplicate)
builder.Services.AddScoped<IEmailService, SmtpEmailService>();

// Only adds if not already registered
builder.Services.TryAddScoped<IEmailService, SmtpEmailService>();
```

This is especially useful for library authors:

```csharp
// Library extension method
public static IServiceCollection AddMyLibrary(this IServiceCollection services)
{
    // Won't override if user already registered their own
    services.TryAddScoped<IEmailService, DefaultEmailService>();
    return services;
}
```

### TryAddEnumerable: Add if Not Same Implementation

```csharp
// Only adds if this exact implementation isn't registered
services.TryAddEnumerable(
    ServiceDescriptor.Scoped<IValidator, EmailValidator>()
);

// This WILL add because it's a different implementation
services.TryAddEnumerable(
    ServiceDescriptor.Scoped<IValidator, PhoneValidator>()
);
```

## Multiple Implementations

Register multiple implementations of the same interface:

```csharp
builder.Services.AddScoped<INotifier, EmailNotifier>();
builder.Services.AddScoped<INotifier, SmsNotifier>();
builder.Services.AddScoped<INotifier, PushNotifier>();
```

Inject all implementations:

```csharp
public class NotificationService
{
    private readonly IEnumerable<INotifier> _notifiers;

    public NotificationService(IEnumerable<INotifier> notifiers)
    {
        _notifiers = notifiers;  // Gets ALL three notifiers!
    }

    public async Task NotifyAll(string message)
    {
        foreach (var notifier in _notifiers)
        {
            await notifier.SendAsync(message);
        }
    }
}
```

<InfoBox type="important">
When injecting a single `INotifier`, you get the **last registered** implementation. Use `IEnumerable<T>` to get all.
</InfoBox>

## Replace and Remove

### Replace an Existing Registration

```csharp
// Replace existing registration with new one
builder.Services.Replace(
    ServiceDescriptor.Scoped<IEmailService, NewEmailService>()
);
```

### Remove a Registration

```csharp
// Find and remove
var descriptor = builder.Services
    .FirstOrDefault(d => d.ServiceType == typeof(IEmailService));

if (descriptor != null)
{
    builder.Services.Remove(descriptor);
}

// Or remove all of a type
builder.Services.RemoveAll<IEmailService>();
```

## Extension Method Pattern

Organize registrations into extension methods:

```csharp
// In ServiceCollectionExtensions.cs
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddUserServices(
        this IServiceCollection services)
    {
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<IUserValidator, UserValidator>();
        return services;
    }

    public static IServiceCollection AddEmailServices(
        this IServiceCollection services,
        string smtpHost)
    {
        services.AddTransient<IEmailService>(provider =>
            new SmtpEmailService(smtpHost));
        return services;
    }
}

// Usage in Program.cs
builder.Services
    .AddUserServices()
    .AddEmailServices("smtp.example.com");
```

## Resolving Services

### In Constructors (Preferred)

```csharp
public class UserController
{
    public UserController(IUserService service) { }
}
```

### Via IServiceProvider (Avoid in App Code)

```csharp
// Only use in factories or composition root!
app.Services.GetRequiredService<IUserService>();
app.Services.GetService<IUserService>();  // Returns null if not found
```

### GetRequiredService vs GetService

| Method                    | If Not Found                       |
| :------------------------ | :--------------------------------- |
| `GetRequiredService<T>()` | Throws `InvalidOperationException` |
| `GetService<T>()`         | Returns `null`                     |

Always prefer `GetRequiredService<T>()` - fail fast, clear error messages.

## Common Registration Patterns

### Configuration Options

```csharp
builder.Services.Configure<SmtpOptions>(
    builder.Configuration.GetSection("Smtp"));

builder.Services.AddTransient<IEmailService, SmtpEmailService>();

public class SmtpEmailService
{
    public SmtpEmailService(IOptions<SmtpOptions> options)
    {
        var host = options.Value.Host;
    }
}
```

### DbContext Registration

```csharp
builder.Services.AddDbContext<AppDbContext>(options =>
{
    options.UseSqlServer(
        builder.Configuration.GetConnectionString("Default"));
});
```

## Key Takeaways

- üìù **Multiple registration forms** - Interface+impl, self, instance, factory
- üîí **TryAdd methods** - Register only if not already registered
- üìã **Multiple implementations** - Use `IEnumerable<T>` to get all
- üîß **Extension methods** - Organize registrations cleanly
- ‚ö†Ô∏è **GetRequiredService** - Prefer over `GetService` for fail-fast behavior

<ProgressCheckpoint section="registration-methods" xpReward={40} />
