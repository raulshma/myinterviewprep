# EF Core Performance

Imagine you're at a grocery store. Would you rather make **one trip** to buy everything you need, or **ten separate trips** to buy one item at a time? The answer is obvious - one trip is much faster! That's exactly what EF Core performance is about - being smart about how we talk to the database.

## Why Performance Matters

Every time your app talks to the database, it takes time:

- üèÉ Network travel time
- üîç Database searching
- üì¶ Data packaging and sending back

The fewer trips to the database, and the less data we fetch, the faster our app!

> **Think of it this way:**
>
> The database is like a warehouse in another city. Every request is a delivery truck. Sending fewer trucks with exactly what you need = faster app!

<PerformanceAnalyzer mode="beginner" />

## The N+1 Problem (The Biggest Mistake!)

The **N+1 problem** is the most common performance mistake. It happens when you accidentally send too many requests to the database.

### ‚ùå The Bad Way (N+1 Problem)

<DotnetCodePreview
  title="N+1 Problem Example"
  code={`// Get all blogs
var blogs = context.Blogs.ToList();  // 1 query

// For each blog, load its posts
foreach (var blog in blogs)
{
var posts = blog.Posts; // N queries!
// This causes a NEW database query each time!
}`}
steps={[
{
lineNumbers: [2],
highlight: "First query",
explanation: "1 query to get all blogs"
},
{
lineNumbers: [7],
highlight: "Many more queries!",
explanation: "If you have 100 blogs, this runs 100 MORE queries!"
}
]}
/>

### ‚úÖ The Good Way (Eager Loading)

<DotnetCodePreview
  title="Fixed with Include"
  code={`// Get all blogs WITH their posts in ONE query
var blogs = context.Blogs
    .Include(b => b.Posts)
    .ToList();

// Now blog.Posts is already loaded!
foreach (var blog in blogs)
{
var posts = blog.Posts; // No extra query!
}`}
steps={[
{
lineNumbers: [2, 3, 4],
highlight: "Include does the magic",
explanation: "One query gets both blogs AND their posts together"
},
{
lineNumbers: [9],
highlight: "Already loaded!",
explanation: "No extra database trip needed"
}
]}
/>

## Only Get What You Need

Don't fetch entire objects when you only need a few fields:

<DotnetCodePreview
  title="Select Only What You Need"
  code={`// ‚ùå Bad: Loading everything
var blogs = context.Blogs.ToList();
var titles = blogs.Select(b => b.Title);
// Loads ALL columns for ALL blogs!

// ‚úÖ Good: Only load titles
var titles = context.Blogs
.Select(b => b.Title)
.ToList();
// Only fetches the Title column!`}
steps={[
{
lineNumbers: [2, 3, 4],
highlight: "Wasteful",
explanation: "Loads all blog data just to get titles"
},
{
lineNumbers: [7, 8, 9],
highlight: "Efficient",
explanation: "Only the Title column is fetched from database"
}
]}
/>

## Quick Tips

| Tip                    | Why It Helps                   |
| :--------------------- | :----------------------------- |
| Use `.Include()`       | Loads related data in one trip |
| Use `.Select()`        | Only fetch columns you need    |
| Use `.AsNoTracking()`  | Faster for read-only data      |
| Avoid loops that query | Batch your database calls      |

## Quick Summary

- **N+1 Problem** = Too many database trips (bad!)
- **Include()** = Load related data together (good!)
- **Select()** = Only fetch what you need (efficient!)
- Fewer trips + Less data = Faster app! üöÄ

<ProgressCheckpoint section="intro-performance" xpReward={25} />
