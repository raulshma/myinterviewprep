# Custom Middleware: Factory Pattern & Advanced Techniques

For complex middleware that needs scoped dependencies or unit testing, the factory-based `IMiddleware` interface provides the cleanest solution.

## Middleware Builder: Advanced Mode

Explore all middleware patterns with dependency injection:

<CustomMiddlewareBuilder mode="advanced" />

## IMiddleware Interface (Factory-Based)

The `IMiddleware` interface provides **per-request instantiation**:

```csharp
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
```

### Why Use IMiddleware?

| **Convention-Based**                      | **IMiddleware (Factory)**               |
| :---------------------------------------- | :-------------------------------------- |
| Singleton (created once)                  | Per-request (new instance each time)    |
| Scoped DI only via method injection       | Scoped DI in constructor works!         |
| Slightly better performance               | Cleaner code for complex dependencies   |

### Implementation Example

```csharp
// AuditMiddleware.cs
public class AuditMiddleware : IMiddleware
{
    private readonly AuditDbContext _db;  // Scoped - works correctly!
    private readonly ICurrentUserService _userService;
    private readonly ILogger<AuditMiddleware> _logger;

    public AuditMiddleware(
        AuditDbContext db,
        ICurrentUserService userService,
        ILogger<AuditMiddleware> logger)
    {
        _db = db;  // Fresh DbContext for each request
        _userService = userService;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var user = _userService.GetCurrentUser();
        var auditEntry = new AuditEntry
        {
            UserId = user?.Id,
            Path = context.Request.Path,
            Method = context.Request.Method,
            Timestamp = DateTime.UtcNow,
            IpAddress = context.Connection.RemoteIpAddress?.ToString()
        };

        try
        {
            await next(context);
            
            auditEntry.StatusCode = context.Response.StatusCode;
            auditEntry.Success = context.Response.StatusCode < 400;
        }
        catch (Exception ex)
        {
            auditEntry.StatusCode = 500;
            auditEntry.Success = false;
            auditEntry.ErrorMessage = ex.Message;
            throw;
        }
        finally
        {
            _db.AuditEntries.Add(auditEntry);
            await _db.SaveChangesAsync();
        }
    }
}
```

### Registration

```csharp
// Must register as a service
builder.Services.AddScoped<AuditMiddleware>();

// Add to pipeline
app.UseMiddleware<AuditMiddleware>();
```

<InfoBox type="important">
  **Critical:** Factory-based middleware MUST be registered in DI! Without `AddScoped<>` or `AddTransient<>`, you'll get a runtime error.
</InfoBox>

## Unit Testing Middleware

Factory-based middleware is easily testable:

```csharp
public class AuditMiddlewareTests
{
    [Fact]
    public async Task InvokeAsync_LogsRequest_ToDatabase()
    {
        // Arrange
        var dbOptions = new DbContextOptionsBuilder<AuditDbContext>()
            .UseInMemoryDatabase("TestDb")
            .Options;
        var db = new AuditDbContext(dbOptions);
        
        var userService = Mock.Of<ICurrentUserService>(
            s => s.GetCurrentUser() == new User { Id = "user123" });
        
        var logger = Mock.Of<ILogger<AuditMiddleware>>();
        
        var middleware = new AuditMiddleware(db, userService, logger);
        
        var context = new DefaultHttpContext();
        context.Request.Path = "/api/test";
        context.Request.Method = "GET";
        
        // Act
        await middleware.InvokeAsync(context, _ => Task.CompletedTask);
        
        // Assert
        var entry = await db.AuditEntries.FirstAsync();
        Assert.Equal("/api/test", entry.Path);
        Assert.Equal("user123", entry.UserId);
        Assert.True(entry.Success);
    }
}
```

## Conditional Middleware Activation

Use `IStartupFilter` for conditional registration:

```csharp
public class ConditionalMiddlewareStartupFilter : IStartupFilter
{
    private readonly IConfiguration _config;

    public ConditionalMiddlewareStartupFilter(IConfiguration config)
    {
        _config = config;
    }

    public Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next)
    {
        return app =>
        {
            if (_config.GetValue<bool>("Features:EnableAudit"))
            {
                app.UseMiddleware<AuditMiddleware>();
            }
            
            if (_config.GetValue<bool>("Features:EnableRateLimit"))
            {
                app.UseMiddleware<RateLimitMiddleware>();
            }
            
            next(app);
        };
    }
}

// Registration
builder.Services.AddTransient<IStartupFilter, ConditionalMiddlewareStartupFilter>();
```

## Response Body Modification

Capturing and modifying response bodies requires stream swapping:

```csharp
public class ResponseCompressionLoggingMiddleware : IMiddleware
{
    private readonly ILogger<ResponseCompressionLoggingMiddleware> _logger;

    public ResponseCompressionLoggingMiddleware(ILogger<ResponseCompressionLoggingMiddleware> logger)
    {
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // Capture the original response body stream
        var originalBody = context.Response.Body;
        
        using var newBody = new MemoryStream();
        context.Response.Body = newBody;

        await next(context);

        // Read what was written
        newBody.Seek(0, SeekOrigin.Begin);
        var responseText = await new StreamReader(newBody).ReadToEndAsync();
        
        _logger.LogInformation(
            "Response ({StatusCode}): {Length} bytes",
            context.Response.StatusCode,
            responseText.Length);

        // Copy to original stream
        newBody.Seek(0, SeekOrigin.Begin);
        await newBody.CopyToAsync(originalBody);
        context.Response.Body = originalBody;
    }
}
```

<InfoBox type="warning">
  **Performance Impact:** Capturing response bodies requires buffering the entire response in memory. Use sparingly and only in development/debugging scenarios!
</InfoBox>

## Request Body Reading

Read request bodies without consuming them:

```csharp
public class RequestLoggingMiddleware : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // Enable request body buffering
        context.Request.EnableBuffering();
        
        using var reader = new StreamReader(
            context.Request.Body, 
            Encoding.UTF8, 
            detectEncodingFromByteOrderMarks: false,
            leaveOpen: true);
        
        var body = await reader.ReadToEndAsync();
        
        // Reset position so next middleware can read
        context.Request.Body.Position = 0;
        
        Console.WriteLine($"Request Body: {body}");
        
        await next(context);
    }
}
```

## Per-Endpoint Middleware

Apply middleware to specific endpoints:

```csharp
// Create a filter that wraps middleware logic
public class LoggingEndpointFilter : IEndpointFilter
{
    public async ValueTask<object?> InvokeAsync(
        EndpointFilterInvocationContext context,
        EndpointFilterDelegate next)
    {
        Console.WriteLine($"Before: {context.HttpContext.Request.Path}");
        
        var result = await next(context);
        
        Console.WriteLine($"After: {context.HttpContext.Response.StatusCode}");
        
        return result;
    }
}

// Apply to specific endpoints
app.MapGet("/logged", () => "Hello")
   .AddEndpointFilter<LoggingEndpointFilter>();

// Or create extension
public static RouteHandlerBuilder WithLogging(this RouteHandlerBuilder builder)
    => builder.AddEndpointFilter<LoggingEndpointFilter>();

app.MapGet("/api/users", GetUsers).WithLogging();
```

## Terminal Middleware with Routing

Create terminal middleware that handles specific routes:

```csharp
// WebSocket middleware example
public class WebSocketMiddleware
{
    private readonly RequestDelegate _next;

    public WebSocketMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        if (context.Request.Path == "/ws" && context.WebSockets.IsWebSocketRequest)
        {
            using var webSocket = await context.WebSockets.AcceptWebSocketAsync();
            await HandleWebSocket(webSocket);
            return;  // Terminal - don't call next
        }
        
        await _next(context);  // Not a WebSocket request, continue
    }
    
    private async Task HandleWebSocket(WebSocket webSocket) { /* ... */ }
}
```

## Performance Best Practices

```csharp
public class OptimizedMiddleware : IMiddleware
{
    // ‚úÖ Cache compiled expressions
    private static readonly Func<HttpContext, bool> _isApiRequest =
        ctx => ctx.Request.Path.StartsWithSegments("/api");

    // ‚úÖ Pre-allocate buffers for common operations
    private static readonly byte[] _notFoundBytes = 
        Encoding.UTF8.GetBytes("Not Found");

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        // ‚úÖ Avoid string allocations in hot paths
        if (_isApiRequest(context))
        {
            // ‚úÖ Use Span/Memory for string operations
            ReadOnlySpan<char> path = context.Request.Path.Value;
            
            if (path.StartsWith("/api/v2"))
            {
                // Handle v2 API
            }
        }

        await next(context);

        // ‚úÖ Write bytes directly instead of strings
        if (context.Response.StatusCode == 404)
        {
            await context.Response.Body.WriteAsync(_notFoundBytes);
        }
    }
}
```

## Key Takeaways

- üè≠ **IMiddleware** ‚Äî Factory pattern for per-request instances
- üíâ **Scoped DI** ‚Äî Works in constructor with IMiddleware
- üß™ **Testable** ‚Äî Easy to unit test with mocked dependencies
- üìù **Body access** ‚Äî Enable buffering to read without consuming
- üéØ **Endpoint filters** ‚Äî Apply logic to specific endpoints
- ‚ö° **Performance** ‚Äî Cache expressions, pre-allocate buffers

<ProgressCheckpoint section="factory-middleware" xpReward={75} />
