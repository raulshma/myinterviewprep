# The ASP.NET Core Request Pipeline

The request pipeline is the heart of ASP.NET Core. It's a sequence of **request delegates** that process HTTP requests and generate responses. Understanding this pipeline is crucial for building efficient web applications.

## How the Pipeline Works

When an HTTP request arrives, it travels through a series of middleware components. Each middleware has chances to:

1. **Inspect or modify** the incoming request
2. **Call the next** middleware in the pipeline
3. **Inspect or modify** the outgoing response
4. **Short-circuit** (stop the request and return early)

<MiddlewarePipelineSimulator mode="intermediate" />

## The Three Middleware Methods

ASP.NET Core provides three ways to configure middleware:

### 1. `Use()` â€” Pass-Through Middleware

Both processes the request AND calls the next middleware:

```csharp
app.Use(async (context, next) =>
{
    // 1. Before: Runs on the way IN
    Console.WriteLine($"Request: {context.Request.Path}");
    
    await next();  // Call the next middleware
    
    // 2. After: Runs on the way OUT
    Console.WriteLine($"Response: {context.Response.StatusCode}");
});
```

### 2. `Run()` â€” Terminal Middleware

**Does NOT call next** â€” the request stops here:

```csharp
app.Run(async context =>
{
    // This is a terminal middleware - request ends here
    await context.Response.WriteAsync("Hello World!");
    // No next() call - this is the end of the line
});
```

<InfoBox type="important">
  `Run()` is always terminal. Any middleware added after `Run()` will never execute!
</InfoBox>

### 3. `Map()` â€” Branch the Pipeline

Creates a **branch** in the pipeline based on the request path:

```csharp
app.Map("/api", apiApp =>
{
    // This branch only handles /api/* requests
    apiApp.UseAuthentication();
    apiApp.UseAuthorization();
    apiApp.MapControllers();
});

app.Map("/health", healthApp =>
{
    // This branch handles /health requests
    healthApp.Run(async ctx => 
        await ctx.Response.WriteAsync("OK"));
});
```

## Short-Circuiting the Pipeline

Sometimes you want to **stop the request early** without calling the next middleware:

```csharp
app.Use(async (context, next) =>
{
    // Short-circuit: Block certain paths
    if (context.Request.Path.StartsWithSegments("/blocked"))
    {
        context.Response.StatusCode = 403;
        await context.Response.WriteAsync("Forbidden!");
        return;  // Don't call next() - request stops here
    }
    
    await next();  // Continue for other paths
});
```

**Common short-circuit scenarios:**
- ğŸ”’ Authentication failures
- ğŸ“ Serving static files (no need to continue)
- âš¡ Returning cached responses
- ğŸš« Blocking unauthorized requests

## The Recommended Middleware Order

Microsoft recommends this order for typical apps:

```csharp
var app = builder.Build();

// 1. Exception/error handling (catch everything)
app.UseExceptionHandler("/Error");

// 2. HSTS (only in production)
app.UseHsts();

// 3. HTTPS Redirection
app.UseHttpsRedirection();

// 4. Static Files (short-circuits for files)
app.UseStaticFiles();

// 5. Routing (matches URL to endpoint)
app.UseRouting();

// 6. CORS (before auth)
app.UseCors();

// 7. Authentication (who are you?)
app.UseAuthentication();

// 8. Authorization (what can you do?)
app.UseAuthorization();

// 9. Custom middleware goes here

// 10. Endpoint execution
app.MapControllers();
```

<InfoBox type="tip">
  **Pro Tip:** Exception Handler should be first so it can catch errors from ALL subsequent middleware!
</InfoBox>

## Key Takeaways

- ğŸ”„ **Use()** processes and passes to next middleware
- ğŸ›‘ **Run()** is terminal â€” ends the pipeline
- ğŸŒ¿ **Map()** creates branches based on paths
- âš¡ **Short-circuiting** stops request processing early
- ğŸ“‹ **Order matters** â€” follow Microsoft's recommended order

<ProgressCheckpoint section="pipeline-flow" xpReward={40} />
